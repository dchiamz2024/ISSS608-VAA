---
title: "Hands-on Exercise 3A"
description: ""
author: "David Chiam"
date: "30 April 2025"
date-modified: "30 April 2025"
format: html
editor: visual
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
---

# **3A - Programming Interactive Data Visualisation with R**

## **3.1 Learning Outcome**

In this hands-on exercise, we will learn how to create interactive data visualisation by using functions provided by **ggiraph** and **plotlyr** packages.

## **3.2 Getting Started**

First, write a code chunk to check, install and launch the following R packages:

-   [**ggiraph**](https://davidgohel.github.io/ggiraph/) for making ‘ggplot’ graphics interactive.
-   [**plotly**](https://plotly.com/r/), R library for plotting interactive statistical graphs.
-   [**DT**](https://rstudio.github.io/DT/) provides an R interface to the JavaScript library [DataTables](https://datatables.net/) that create interactive table on html page.
-   [**tidyverse**](https://www.tidyverse.org/), a family of modern R packages specially designed to support data science, analysis and communication task including creating static statistical graphs.
-   [**patchwork**](https://patchwork.data-imaginist.com/) for combining multiple ggplot2 graphs into one figure.

The code chunk below will be used to accomplish the task.

```{r }

pacman::p_load(ggiraph, plotly, 
               patchwork, DT, tidyverse,
               ggplot2) 
```

## **3.3 Importing Data**

In this section, *Exam_data.csv* provided will be used. Using [*read_csv()*](https://readr.tidyverse.org/reference/read_delim.html) of **readr** package, import *Exam_data.csv* into R.

The code chunk below `read_csv()` of **readr** package is used to import *Exam_data.csv* data file into R and save it as an tibble data frame called `exam_data`.

```{r }
exam_data <- read_csv("DataEx03/Exam_data.csv")
```

## **3.4 Interactive Data Visualisation - ggiraph methods**

[ggiraph](https://davidgohel.github.io/ggiraph/index.html) is an htmlwidget and a ggplot2 extension. It allows ggplot graphics to be interactive.

Interactive is made with [**ggplot geometries**](https://davidgohel.github.io/ggiraph/reference/index.html#section-interactive-geometries) that can understand three arguments:

-   `Tooltip`: a column of data-sets that contain tooltips to be displayed when the mouse is over elements.
-   `Onclick`: a column of data-sets that contain a JavaScript function to be executed when elements are clicked.
-   `Data_id`: a column of data-sets that contain an id to be associated with elements.

If it used within a shiny application, elements associated with an id (data_id) can be selected and manipulated on client and server sides. Refer to this [article](https://www.ardata.fr/ggiraph-book/selections.html) for more detail explanation.

::: How-Does-it-Work
![](/Images/teacher.png){width="42"} [<strong>How does it work?</strong>]{style="font-size: 30px; vertical-align: middle;"}

It extends **ggplot2** with:

-   interactive geom functions: `geom_point_interactive()`, `geom_col_interactive()`, etc.
-   interactive scale functions: `scale_color_continuous_interactive()`, `scale_fill_manual_interactive()`, etc.
-   interactive facet functions: `facet_wrap_interactive()`, `facet_grid_interactive()` with `labeller_interactive()`.
-   interactive guide functions: `guide_colorbar_interactive()`, `guide_legend_interactive()`.
-   interactive theme elements: `element_line_interactive()`, `element_rect_interactive()`, `label_interactive()`.
:::

### **3.4.1 Tooltip effect with *tooltip* aesthetic**

Below shows a typical code chunk to plot an interactive statistical graph by using **ggiraph** package. Notice that the code chunk consists of two parts. First, an ggplot object will be created. Next, [`girafe()`](https://davidgohel.github.io/ggiraph/reference/girafe.html) of **ggiraph** will be used to create an interactive svg object.

```{r, echo=TRUE, results='hide'}

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = ID),
    stackgroups = TRUE, 
    binwidth = 1, 
    method = "histodot") +
  scale_y_continuous(NULL, 
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618
)
```

Notice that two steps are involved. First, an interactive version of ggplot2 geom (i.e. [`geom_dotplot_interactive()`](https://davidgohel.github.io/ggiraph/reference/geom_dotplot_interactive.html)) will be used to create the basic graph. Then, [`girafe()`](https://davidgohel.github.io/ggiraph/reference/girafe.html) will be used to generate an svg object to be displayed on an html page.

## **3.5 Interactivity**

By hovering the mouse pointer on an data point of interest, the student’s ID will be displayed.

```{r, echo=FALSE}

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = ID),
    stackgroups = TRUE, 
    binwidth = 1, 
    method = "histodot") +
  scale_y_continuous(NULL, 
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 6,
  height_svg = 6*0.618
)
```

### **3.5.1 Displaying multiple information on tooltip**

The content of the tooltip can be customised by including a list object as shown in the code chunk below.

```{r, echo=TRUE, results='hide'}

exam_data$tooltip <- c(paste0(     
  "Name = ", exam_data$ID,         
  "\n Class = ", exam_data$CLASS)) 

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = exam_data$tooltip), 
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 8,
  height_svg = 8*0.618
)
```

The first three lines of codes in the code chunk create a new field called *tooltip*. At the same time, it populates text in ID and CLASS fields into the newly created field. Next, this newly created field is used as tooltip field as shown in the code of line 7.

## **3.6 Interactivity**

By hovering the mouse pointer on an data point of interest, the student’s ID and Class will be displayed.

```{r, echo=FALSE}

exam_data$tooltip <- c(paste0(     
  "Name = ", exam_data$ID,         
  "\n Class = ", exam_data$CLASS)) 

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(tooltip = exam_data$tooltip), 
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot") +
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(
  ggobj = p,
  width_svg = 8,
  height_svg = 8*0.618
)
```

### **3.6.1 Customising Tooltip style**

Code chunk below uses [`opts_tooltip()`](https://davidgohel.github.io/ggiraph/reference/opts_tooltip.html) of **ggiraph** to customize tooltip rendering by add css declarations.

```{r, echo=TRUE, results='hide'}

tooltip_css <- "background-color:#27dfff; #<<here
                font-style:bold; 
                color:black;" #<<here

exam_data$tooltip <- c(paste0(     
  "Name = ", exam_data$ID,         
  "\n Class = ", exam_data$CLASS)) 

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = tooltip),                   
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(    #<<here
    opts_tooltip(    #<<here
      css = tooltip_css)) #<<here
)                                        


```

Notice that the inital plot had a background colour of the tooltip as black and the font colour as white and bold.

Now with the adjusted code chunk, the background colour of the tooltip is blue and the font colour as black and bold.

-   Refer to [Customizing girafe objects](https://www.ardata.fr/ggiraph-book/customize.html) to learn more about how to customise ggiraph objects.

```{r, echo=FALSE}

tooltip_css <- "background-color:#27dfff; #<<here
                font-style:bold;
                color:black;" #<<here

exam_data$tooltip <- c(paste0(     
  "Name = ", exam_data$ID,         
  "\n Class = ", exam_data$CLASS)) 

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = tooltip),                   
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(    #<<here
    opts_tooltip(    #<<here
      css = tooltip_css)) #<<here
)                                        

```

### **3.6.2 Displaying statistics on tooltip**

Code chunk below shows an advanced way to customise tooltip. In this example, a function is used to compute 90% confident interval of the mean. The derived statistics are then displayed in the tooltip.

```{r}

tooltip <- function(y, ymax, accuracy = .01) {
  mean <- scales::number(y, accuracy = accuracy)
  sem <- scales::number(ymax - y, accuracy = accuracy)
  paste("Mean maths scores:", mean, "+/-", sem)
}

gg_point <- ggplot(data=exam_data, 
                   aes(x = RACE),
) +
  stat_summary(aes(y = MATHS, 
                   tooltip = after_stat(  
                     tooltip(y, ymax))),  
    fun.data = "mean_se", 
    geom = GeomInteractiveCol,  
    fill = "light blue"
  ) +
  stat_summary(aes(y = MATHS),
    fun.data = mean_se,
    geom = "errorbar", width = 0.2, size = 0.2
  )

girafe(ggobj = gg_point,
       width_svg = 8,
       height_svg = 8*0.618)

```

### **3.6.3 Hover effect with *data_id* aesthetic**

Code chunk below shows the second interactive feature of ggiraph, namely `data_id`.

```{r, echo=TRUE, results='hide'}

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(           
    aes(data_id = CLASS),             
    stackgroups = TRUE,               
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618                      
)                                        
```

Interactivity: Elements associated with a *data_id* (i.e CLASS) will be highlighted upon mouse over.

```{r, echo=FALSE}

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(           
    aes(data_id = CLASS),             
    stackgroups = TRUE,               
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618                      
)   
```

### **3.6.4 Styling hover effect**

In the code chunk below, css codes are used to change the highlighting effect.

```{r, echo=TRUE, results='hide'}

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = CLASS),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(                        
    opts_hover(css = "fill: #ff9305;"),  
    opts_hover_inv(css = "opacity:0.2;") 
  )                                        
)                                        

```

Interactivity: Elements associated with a *data_id* (i.e CLASS) will be highlighted upon mouse over.

Note: Different from previous example, in this example the ccs customisation request are encoded directly.

```{r, echo=FALSE}

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = CLASS),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(                        
    opts_hover(css = "fill: #ff9305;"),  
    opts_hover_inv(css = "opacity:0.2;") 
  )                                        
)                                        

```

### **3.6.5 Combining tooltip and hover effect**

There are time that we want to combine tooltip and hover effect on the interactive statistical graph as shown in the code chunk below.

```{r, echo=TRUE, results='hide'}

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = CLASS, 
        data_id = CLASS),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(                        
    opts_hover(css = "fill: #ff9305;"),  
    opts_hover_inv(css = "opacity:0.2;") 
  )                                        
)                                        

```

Interactivity: Elements associated with a *data_id* (i.e CLASS) will be highlighted upon mouse over. At the same time, the tooltip will show the CLASS.

```{r, echo=FALSE}

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(tooltip = CLASS, 
        data_id = CLASS),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618,
  options = list(                        
    opts_hover(css = "fill: #ff9305;"),  
    opts_hover_inv(css = "opacity:0.2;") 
  )                                        
)          

```

### **3.6.6 Click effect with onclick**

`onclick` argument of ggiraph provides hotlink interactivity on the web.

The code chunk below shown an example of `onclick`.

```{r, echo=TRUE, results='hide'}

exam_data$onclick <- sprintf("window.open(\"%s%s\")",
"https://www.moe.gov.sg/schoolfinder?journey=Primary%20school",
as.character(exam_data$ID))

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(onclick = onclick),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618)                                                                                
```

Interactivity: Web document link with a data object will be displayed on the web browser upon mouse click.

```{r, echo=FALSE}

exam_data$onclick <- sprintf("window.open(\"%s%s\")",
"https://www.moe.gov.sg/schoolfinder?journey=Primary%20school",
as.character(exam_data$ID))

p <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(onclick = onclick),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +               
  scale_y_continuous(NULL,               
                     breaks = NULL)
girafe(                                  
  ggobj = p,                             
  width_svg = 6,                         
  height_svg = 6*0.618) 

```

::: callout-warning
## Warning ⚠️

Note that click actions must be a string column in the dataset containing valid JavaScript instructions.
:::

### **3.6.7 Coordinated Multiple Views with ggiraph**

Coordinated multiple views methods has been implemented in the data visualisation below.

Notice that when a data point of one of the dotplot is selected, the corresponding data point ID on the second data visualisation will be highlighted too.

In order to build a coordinated multiple views as shown in the example above, the following programming strategy will be used:

1.  Appropriate interactive functions of **ggiraph** will be used to create the multiple views.

2.  *patchwork* function of [patchwork](https://patchwork.data-imaginist.com/) package will be used inside girafe function to create the interactive coordinated multiple views.

```{r}
p1 <- ggplot(data=exam_data, 
       aes(x = MATHS)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") +  
  coord_cartesian(xlim=c(0,100)) + 
  scale_y_continuous(NULL,               
                     breaks = NULL)

p2 <- ggplot(data=exam_data, 
       aes(x = ENGLISH)) +
  geom_dotplot_interactive(              
    aes(data_id = ID),              
    stackgroups = TRUE,                  
    binwidth = 1,                        
    method = "histodot") + 
  coord_cartesian(xlim=c(0,100)) + 
  scale_y_continuous(NULL,               
                     breaks = NULL)

girafe(code = print(p1 + p2), 
       width_svg = 6,
       height_svg = 3,
       options = list(
         opts_hover(css = "fill: #202020;"),
         opts_hover_inv(css = "opacity:0.2;")
         )
       ) 

```

The patchwork package was used to stack multiple ggplot objects vertically using the / operator. This layout was wrapped within the girafe() function to render a single interactive widget.

Custom styling was applied using opts_hover() and opts_hover_inv() inside girafe() to enhance interactivity. When a student is selected, their dot turns dark, while other points fade slightly in the background. Additionally, the colour of the tooltip background was customised to blue and the font colour as black and bold.

The final result is an integrated view where interactivity in one plot automatically updates the display across all other plots, allowing for rich comparative analysis across subjects.

```{r}

tooltip_css <- "background-color:#27dfff; 
                font-style:bold; 
                color:black;" 

# Create tooltip text combining ID and CLASS
exam_data$tooltip <- paste0(
  "ID: ", exam_data$ID, "\nClass: ", exam_data$CLASS
)

# Create 3 interactive ggplots with the same structure
p1 <- ggplot(exam_data, aes(x = MATHS)) +
  geom_dotplot_interactive(
    aes(data_id = ID, tooltip = tooltip),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot"
  ) +
  coord_cartesian(xlim = c(0, 100)) +
  scale_y_continuous(NULL, breaks = NULL) +
  ggtitle("Maths")

p2 <- ggplot(exam_data, aes(x = ENGLISH)) +
  geom_dotplot_interactive(
    aes(data_id = ID, tooltip = tooltip),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot"
  ) +
  coord_cartesian(xlim = c(0, 100)) +
  scale_y_continuous(NULL, breaks = NULL) +
  ggtitle("English")

p3 <- ggplot(exam_data, aes(x = SCIENCE)) +
  geom_dotplot_interactive(
    aes(data_id = ID, tooltip = tooltip),
    stackgroups = TRUE,
    binwidth = 1,
    method = "histodot"
  ) +
  coord_cartesian(xlim = c(0, 100)) +
  scale_y_continuous(NULL, breaks = NULL) +
  ggtitle("Science")


# Use patchwork's vertical stacking with /
combined_plot <- p1 / p2 / p3

# Render interactive stacked plots
girafe(
  ggobj = combined_plot,
  width_svg = 6,
  height_svg = 8,  # Increase height for stacked layout
  options = list(
    opts_hover(css = "fill: #ff9305; stroke: black; "),
    opts_hover_inv(css = "opacity:0.2;"),
    opts_tooltip(css = tooltip_css) 
  )
)

```

## **3.7 Interactive Data Visualisation - plotly methods!**

Plotly’s R graphing library create interactive web graphics from **ggplot2** graphs and/or a custom interface to the (MIT-licensed) JavaScript library [**plotly.js**](https://plotly.com/javascript/) inspired by the grammar of graphics. Different from other plotly platform, plot.R is free and open source.

There are two ways to create interactive graph by using plotly, they are:

-   by using *plot_ly()*, and
-   by using *ggplotly()*

### **3.7.1 Creating an interactive scatter plot: plot_ly() method**

The tabset below shows an example a basic interactive plot created by using *plot_ly()*.

::: panel-tabset
## The Plot

```{r, echo=FALSE}

plot_ly(data = exam_data, 
        x = ~MATHS, 
        y = ~ENGLISH,
        type = 'scatter',
        mode = 'markers') %>%
  layout(
    title = list(
      text = "<b>English vs. Maths</b>",
      x = 0.5,           # center the title
      xanchor = "center"
    )
  )

```

## The Code Chunk

```{r, echo=TRUE, results='hide'}

plot_ly(data = exam_data, 
        x = ~MATHS, 
        y = ~ENGLISH,
        type = 'scatter',
        mode = 'markers') %>%
  layout(
    title = list(
      text = "<b>English vs. Maths</b>",
      x = 0.5,           # center the title
      xanchor = "center"
    )
  )

```
:::

### **3.7.2 Working with visual variable: plot_ly() method**

In the code chunk below, *color* argument is mapped to a qualitative visual variable (i.e. RACE).

::: panel-tabset
## The Plot

```{r, echo=FALSE}

plot_ly(data = exam_data, 
        x = ~MATHS, 
        y = ~ENGLISH,
        color = ~RACE,
        type = 'scatter',
        mode = 'markers') %>%
  layout(
    title = list(
      text = "<b>English vs. Maths</b>",
      x = 0.5,           # center the title
      xanchor = "center"
    )
  )

```

## The Code Chunk

```{r, echo=TRUE, results='hide'}

plot_ly(data = exam_data, 
        x = ~MATHS, 
        y = ~ENGLISH,
        color = ~RACE,
        type = 'scatter',
        mode = 'markers') %>%
  layout(
    title = list(
      text = "<b>English vs. Maths</b>",
      x = 0.5,           # center the title
      xanchor = "center"
    )
  )

```
:::

### **3.7.3 Creating an interactive scatter plot: ggplotly() method**

The code chunk below plots an interactive scatter plot by using *ggplotly()*.

::: panel-tabset
## The Plot

```{r, echo=FALSE}

p <- ggplot(data=exam_data, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100)) +
  ggtitle("English vs. Maths") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5))  # bold & centered title
  
ggplotly(p)

```

## The Code Chunk

```{r, echo=TRUE, results='hide'}

p <- ggplot(data=exam_data, 
            aes(x = MATHS,
                y = ENGLISH)) +
  geom_point(size=1) +
  coord_cartesian(xlim=c(0,100),
                  ylim=c(0,100)) +
  ggtitle("English vs. Maths") +
  theme(plot.title = element_text(face = "bold", hjust = 0.5))  # bold & centered title
  
ggplotly(p)

```
:::

### **3.7.4 Coordinated Multiple Views with plotly**

The creation of a coordinated linked plot by using plotly involves three steps:

-   [`highlight_key()`](https://www.rdocumentation.org/packages/plotly/versions/4.9.2/topics/highlight_key) of **plotly** package is used as shared data.

-   two scatterplots will be created by using ggplot2 functions.

-   lastly, [*subplot()*](https://plotly.com/r/subplots/) of **plotly** package is used to place them next to each other side-by-side.

Thing to learn from the code chunk:

highlight_key() simply creates an object of class crosstalk::SharedData. Visit this link to learn more about crosstalk.

::: panel-tabset
## The Plot

```{r, echo=FALSE}

library(crosstalk)

# Use crosstalk to enable linking
d <- highlight_key(exam_data)

# Plot 1: English vs. Maths
p1 <- ggplot(data = d, aes(x = MATHS, y = ENGLISH)) +
  geom_point(size = 1) +
  coord_cartesian(xlim = c(0, 100), ylim = c(0, 100)) +
  labs(x = "Maths", y = "English")

# Plot 2: Science vs. Maths
p2 <- ggplot(data = d, aes(x = MATHS, y = SCIENCE)) +
  geom_point(size = 1) +
  coord_cartesian(xlim = c(0, 100), ylim = c(0, 100)) +
  labs(x = "Maths", y = "Science")

# Combine into interactive subplot
subplot(
  ggplotly(p1), 
  ggplotly(p2), 
  nrows = 1,         # Side-by-side layout
  margin = 0.06, 
  shareX = FALSE, 
  shareY = FALSE,
  titleX = TRUE, 
  titleY = TRUE
) %>%
  layout(
    font = list(size = 10),  # Axis font size
    margin = list(t = 80),   # Add top margin (in pixels) to prevent title cutoff
    annotations = list(
      list(  # Title for left plot
        text = "<b>English vs. Maths</b>",
        x = 0.1, xref = "paper",
        y = 1.1, yref = "paper",
        showarrow = FALSE,
        font = list(size = 20)  # 2x axis font size
      ),
      list(  # Title for right plot
        text = "<b>Science vs. Maths</b>",
        x = 0.9, xref = "paper",
        y = 1.1, yref = "paper",
        showarrow = FALSE,
        font = list(size = 20)  # 2x axis font size
      )
    )
  )

```

## The Code Chunk

```{r, echo=TRUE, results='hide'}

library(crosstalk)

# Use crosstalk to enable linking
d <- highlight_key(exam_data)

# Plot 1: English vs. Maths
p1 <- ggplot(data = d, aes(x = MATHS, y = ENGLISH)) +
  geom_point(size = 1) +
  coord_cartesian(xlim = c(0, 100), ylim = c(0, 100)) +
  labs(x = "Maths", y = "English")

# Plot 2: Science vs. Maths
p2 <- ggplot(data = d, aes(x = MATHS, y = SCIENCE)) +
  geom_point(size = 1) +
  coord_cartesian(xlim = c(0, 100), ylim = c(0, 100)) +
  labs(x = "Maths", y = "Science")

# Combine into interactive subplot
subplot(
  ggplotly(p1), 
  ggplotly(p2), 
  nrows = 1,         # Side-by-side layout
  margin = 0.06, 
  shareX = FALSE, 
  shareY = FALSE,
  titleX = TRUE, 
  titleY = TRUE
) %>%
  layout(
    font = list(size = 10),  # Axis font size
    margin = list(t = 80),   # Add top margin (in pixels) to prevent title cutoff
    annotations = list(
      list(  # Title for left plot
        text = "<b>English vs. Maths</b>",
        x = 0.1, xref = "paper",
        y = 1.05, yref = "paper",
        showarrow = FALSE,
        font = list(size = 20)  # 2x axis font size
      ),
      list(  # Title for right plot
        text = "<b>Science vs. Maths</b>",
        x = 0.9, xref = "paper",
        y = 1.05, yref = "paper",
        showarrow = FALSE,
        font = list(size = 20)  # 2x axis font size
      )
    )
  )

```
:::

## **3.8 Interactive Data Visualisation - crosstalk methods!**

[Crosstalk](https://rstudio.github.io/crosstalk/index.html) is an add-on to the htmlwidgets package. It extends htmlwidgets with a set of classes, functions, and conventions for implementing cross-widget interactions (currently, linked brushing and filtering).

### **3.8.1 Interactive Data Table: DT package**

-   A wrapper of the JavaScript Library [DataTables](https://datatables.net/)

-   Data objects in R can be rendered as HTML tables using the JavaScript library ‘DataTables’ (typically via R Markdown or Shiny).

```{r}
DT::datatable(exam_data, class= "compact")
```




