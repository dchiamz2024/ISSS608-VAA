---
title: "Hands-on Exercise 5e"
description: ""
author: "David Chiam"
date: "10 May 2025"
date-modified: "10 May 2025"
format: html
editor: visual
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
---

# **13  Treemap Visualisation with R**

## **13.1 Overview**

In this hands-on exercise, you will gain hands-on experiences on designing treemap using appropriate R packages. The hands-on exercise consists of three main section. First, you will learn how to manipulate transaction data into a treemap strcuture by using selected functions provided in **dplyr** package. Then, you will learn how to plot static treemap by using **treemap** package. In the third section, you will learn how to design interactive treemap by using **d3treeR** package.

## **13.2 Installing and Launching R Packages**

Before we get started, you are required to check if **treemap** and **tidyverse** pacakges have been installed in you R.

```{r}

pacman::p_load(treemap, treemapify, tidyverse) 

```

## **13.3 Data Wrangling**

In this exercise, *REALIS2018.csv* data will be used. This dataset provides information of private property transaction records in 2018. The dataset is extracted from REALIS portal (https://spring.ura.gov.sg/lad/ore/login/index.cfm) of Urban Redevelopment Authority (URA).

### **13.3.1 Importing the data set**

In the code chunk below, *read_csv()* of **readr** is used to import realis2018.csv into R and parsed it into tibble R data.frame format.

```{r}

realis2018 <- read_csv("data/realis2018.csv")

```

The output tibble data.frame is called *realis2018*.

### **13.3.2 Data Wrangling and Manipulation**

The data.frame *realis2018* is in trasaction record form, which is highly disaggregated and not appropriate to be used to plot a treemap. In this section, we will perform the following steps to manipulate and prepare a data.frtame that is appropriate for treemap visualisation:

-   group transaction records by *Project Name*, *Planning Region*, *Planning Area*, *Property Type* and *Type of Sale*, and
-   compute *Total Unit Sold*, *Total Area*, *Median Unit Price* and *Median Transacted Price* by applying appropriate summary statistics on *No. of Units*, *Area (sqm)*, *Unit Price (\$ psm)* and *Transacted Price (\$)* respectively.

Two key verbs of **dplyr** package, namely: *group_by()* and *summarize()* will be used to perform these steps.

*group_by()* breaks down a data.frame into specified groups of rows. When you then apply the verbs above on the resulting object they’ll be automatically applied “by group”.

Grouping affects the verbs as follows:

-   grouped *select()* is the same as ungrouped *select()*, except that grouping variables are always retained.
-   grouped *arrange()* is the same as ungrouped; unless you set *.by_group = TRUE*, in which case it orders first by the grouping variables.
-   *mutate()* and *filter()* are most useful in conjunction with window functions (like *rank()*, or *min(x) == x*). They are described in detail in vignette(“window-functions”).
-   *sample_n()* and *sample_frac()* sample the specified number/fraction of rows in each group.
-   *summarise()* computes the summary for each group.

In our case, *group_by()* will used together with *summarise()* to derive the summarised data.frame.

### **13.3.3 Grouped summaries without the Pipe**

The code chank below shows a typical two lines code approach to perform the steps.

```{r}

realis2018_grouped <- group_by(realis2018, `Project Name`,
                               `Planning Region`, `Planning Area`, 
                               `Property Type`, `Type of Sale`)
realis2018_summarised <- summarise(realis2018_grouped, 
                          `Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE),
                          `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),
                          `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE), 
                          `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))

```

::: callout-note
Aggregation functions such as *sum()* and *meadian()* obey the usual rule of missing values: if there’s any missing value in the input, the output will be a missing value. The argument *na.rm = TRUE* removes the missing values prior to computation.
:::

The code chunk above is not very efficient because we have to give each intermediate data.frame a name, even though we don’t have to care about it.

### **13.3.4 Grouped summaries with the *pipe***

The code chunk below shows a more efficient way to tackle the same processes by using the *pipe*, %\>%:

```{r}

realis2018_summarised <- realis2018 %>% 
  group_by(`Project Name`,`Planning Region`, 
           `Planning Area`, `Property Type`, 
           `Type of Sale`) %>%
  summarise(`Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE), 
            `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),
            `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE),
            `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))

```
