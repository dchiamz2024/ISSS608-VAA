{
  "hash": "fd18b1cacea717fbfec49547cc76ab2d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-Home Assignment 2\"\ndescription: \"\"\nauthor: \"David Chiam\"\ndate: \"22 May 2025\"\ndate-modified: \"23 May 2025\"\nformat: html\neditor: visual\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n## **1. Getting Started**\n\n### 1.1 - Load the R packages for this assignment\n\nFor the purpose of this assignment, five R packages will be used. They are tidyverse, jsonlite, tidygraph, ggraph and SmartEDA.\n\nIn the code chunk below, p_load() of pacman package is used to load the R packages into R environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, jsonlite, \n               tidygraph, ggraph,\n               SmartEDA)\n```\n:::\n\n\n### 1.2 - Load the R packages for this assignment\n\nWe will be loading the *MC1_graph.json* file given for Vast Challange 2025's Mini-Challenge 1. The code chunk below, `fromJSON()` of **jsonlite** package is used to import *MC1_graph.json* file into R and save the output object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkg <- fromJSON(\"Data/mc1_graph.json\")\n```\n:::\n\n\n### 1.3 - Inspect Structure\n\nBefore preparing the data, it is always a good practice to examine the structure of *kg* object. In the code chunk below `str()` is used to reveal the structure of *kg* object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(kg, max.level = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 5\n $ directed  : logi TRUE\n $ multigraph: logi TRUE\n $ graph     :List of 2\n $ nodes     :'data.frame':\t17412 obs. of  10 variables:\n $ links     :'data.frame':\t37857 obs. of  4 variables:\n```\n\n\n:::\n:::\n\n\n### 1.4 - Extract the edges and nodes tables\n\nNext, we will use the `as_tibble()` of **tibble** package package to extract the nodes and links tibble data frames from *kg* object into two separate tibble data frames called *nodes_tbl* and *edges_tbl* respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnodes_tb1 <- as_tibble(kg$nodes)\nedges_tb1 <- as_tibble(kg$links)\n```\n:::\n\n\n## Initial EDA\n\nWe then apply EDA methodology to examine data. The code chunk below uses theggplot2 functions to reveal the frequency distribution of *Edge Type* field of *edges_tbl*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = edges_tb1,\n       aes(y = `Edge Type`)) + \n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = nodes_tb1,\n       aes(y = `Node Type`)) + \n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## Creating Knowledge Graph\n\nThis is\n\n### Step 1: Mapping from node id to row index\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid_map <- tibble(id = nodes_tb1$id,\n                 index = seq_len(nrow(nodes_tb1)))\n```\n:::\n\n\nThis ensures each id from your node list is mapped to the correct row number.\n\n### Step 2: Map source and target IDs to row indices\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_tb1 <- edges_tb1 %>%\n  left_join(id_map, by = c(\"source\" = \"id\")) %>%\n  rename(from = index) %>%\n  left_join(id_map, by = c(\"target\" = \"id\")) %>%\n  rename(to = index)\n```\n:::\n\n\n### Step 3: Filter out any unmatched (invalid) edges\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_tb1 <- edges_tb1 %>%\n  filter(!is.na(from), !is.na(to))\n```\n:::\n\n\n### Step 4: Creating the graph\n\nLastly, `tbl_grpah()` is used to create tidygraph's graph object by using the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph <- tbl_graph(nodes = nodes_tb1,\n                   edges = edges_tb1,\n                   directed = kg$directed)\n```\n:::\n\n\n## Visualising the knowledge graph\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n```\n:::\n\n\n### Visualising the whole Graph\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(graph, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3,\n                colour = \"gray\") +\n  geom_node_point(aes(colour = `Node Type`),\n                  size = 4)+\n  geom_node_text(aes(label = name),\n                repel = TRUE,\n                size = 2.5) +\n  theme_void()\n```\n:::\n\n\n### Visualising the sub-graph\n\nIn this section, we are interested to create a sub-graph based on \\*Memberof\\* value in *Edge Type* column of the *edges* data frame.\n\n#### Step 1: Filter edges to only \"Memberof\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_memberof <- graph %>%\n  activate(edges) %>%\n  filter(`Edge Type` == \"MemberOf\")\n```\n:::\n\n\n#### Step 2: Extract only connected nodes (i.e., used in these edges)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nused_node_indices <- graph_memberof %>%\n  activate(edges) %>%\n  as_tibble() %>%\n  select(from, to) %>%\n  unlist() %>%\n  unique()\n```\n:::\n\n\n#### Step 3: Keep only those nodes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_memberof <- graph_memberof %>%\n  activate(nodes) %>%\n  mutate(row_id = row_number()) %>%\n  filter(row_id %in% used_node_indices) %>%\n  select(-row_id)    # optional cleanup\n```\n:::\n\n\n#### Plot the sub-graph\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(graph_memberof,\n       layout = \"fr\") +\n  geom_edge_link(alpha = 0.3,\n                 colour = \"gray\") +\n  geom_node_point(aes(colour = `Node Type`),\n                  size = 1)+\n  geom_node_text(aes(label = name), \n                 repel = TRUE, \n                 size = 2.5) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](Take-Home_Ex02_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n",
    "supporting": [
      "Take-Home_Ex02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}